vec3 hashedWave(vec2 rg, float time, float magnitude, float b)
{
    vec3 result;
    result = vec3(cos(time * rg * magnitude),b);
    return result;
}
//given our passed vec2 in [-1,+1] space we bring it to [0,+1] space and translate to color for our purposes

vec2 barrelDistortion(vec2 loc, float magnitude, float radius)
{
    float theta = atan(loc.y,loc.x);
    radius = pow(radius, magnitude);
    loc.x = radius * cos(theta);
    loc.y = radius * sin(theta);
    
    return 0.5 * (loc + 1.0);
}

//Transfer relative position (x or y coord) with the given axis (x or y) 
//relative to axis itself if you want down the middle pass in .5, .25 for quarter of the screen, etc.
//Multiplication costs less to do then division is why we do this.
bool splitScreen(float relativePos, float axisSplit, float sectionSplit)
{
    return (relativePos < axisSplit * sectionSplit);
}

//Currently displays desired color if you are within the circle & in the top right or top left of the circle
//More to come with tinkering with this function.
vec4 drawSplitCircle(vec2 loc, vec2 center , float radius, vec4 currentCol, vec4 desiredColOne, vec4 desiredColTwo)
{
//efficient drawing of circle instead of using float dist = length(loc - center);
// if(dist <= radius)  
    vec2 diff = loc - center;

    if (dot(diff,diff) <= radius * radius)
       {
       //if left side of the screen
           if(splitScreen(loc.x, center.x, 1.0))
                {
                    //if bottom left of the screen
                    if(splitScreen(loc.y, center.y, 1.0))
                        return desiredColOne;
                    //if top left
                    else
                        return desiredColOne * (vec4(1.0,0.0,1.0,1.0) * vec4(loc.y, 0.0, loc.x,1.0));
                }
                //if right side
           if(!splitScreen(loc.x, center.x, 1.0))
               {
                   //if top right
                   if(!splitScreen(loc.y, center.y, 1.0))
                   {
                       return desiredColTwo;
                   }
                   else
                   //if bottom right
                   return desiredColTwo * vec4(0.0,1.0,0.0,1.0);
               }
        }
    return currentCol * vec4(0.92,0.92,0.92,1.0);
}

// calcViewport: calculate the viewing plane (viewport) coordinate
//    viewport:       output viewing plane coordinate
//    ndc:            output normalized device coordinate
//    uv:             output screen-space coordinate
//    aspect:         output aspect ratio of screen
//    resolutionInv:  output reciprocal of resolution
//    viewportHeight: input height of viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv,
                  out float aspect, out vec2 resolutionInv,
                  in float viewportHeight, in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)
    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));
}
//turning this into a float hit
float hitSphere(in vec4 rayDirection, in vec4 rayOrigin, float radius, vec3 center)
{
    vec3 dist = rayOrigin.xyz - center;
    float a = dot(rayDirection, rayDirection);
    float half_b = dot(dist, rayDirection.xyz);
    float c = dot(dist,dist) - radius * radius;
    float doesHit = half_b * half_b - a * c;
    
    if(doesHit < 0.0)
    {
        return -1.0;
    }
    else
    {
        return (-half_b - sqrt(doesHit) / a);
    }
}



//closest to making a class we will get with GLSL

struct sRay
{
    vec4 origin;
    vec4 direction;

};

//initialize our ray struct
sRay newRay(in vec3 origin, in vec3 direction)
{
    sRay ray;
    ray.origin = vec4(origin, 1.0);
    ray.direction = vec4(direction, 0.0);
    return ray;
}

//calculate a point along a ray and return it.
vec4 atRay(float distAlongRay, sRay ray)
{
    return ray.origin + distAlongRay * ray.direction;
}

// calcRay: calculate the ray direction and origin for the current pixel
//    rayDirection: output direction of ray from origin
//    rayOrigin:    output origin point of ray
//    viewport:     input viewing plane coordinate (use above function to calculate)
//    focalLength:  input distance to viewing plane
void calcRay(out sRay ray, in vec2 viewport, in float focalLength)
{
    ray = newRay(vec3(0.0), vec3(viewport, -focalLength));
}


// calcColor: calculate the color of a pixel given a ray
//    rayDirection: input ray direction
//    rayOrigin:    input ray origin
vec4 calcColor(in sRay ray, in float time, in vec2 resolution, in vec2 fragCoord)
{
//    vec3 unit_direction = rayDirection
    //return normalized color if within our sphere shown by if vari > 0.0.
    float vari = hitSphere(ray.direction, ray.origin,0.5f, vec3(0,0,-1));
    if (vari > 0.0)
    {
        if(splitScreen(fragCoord.x, resolution.x, 0.5))
        {
            return vec4(1.0,0.0,0.0,1.0);
        }
        //normalized front face of the sphere(reason we subtract the vec3 sphere pos)
        vec3 normal = vec3(atRay(vari , ray)) - vec3(0,0,-1);
        return vec4(0.5 * vec3(normal.x + 1.0, normal.y + 1.0, normal.z + 1.0), 1.0);
    }
//otherwise BackgroundColor
// our formula for lerp is still (1.0 - t) * white(starting color) + t * blue(ending color).
    vec4 hashBlue = vec4(hashedWave(vec2(0.25,0.3), time,  1.0f, 1.0),1.0);
    vec4 hashGreen = vec4(hashedWave(vec2(0.3, .75), time, 1.0f, 1.25),1.0);
    vari = 0.5f * (ray.direction.y + 1.0f);
    return (1.0 - vari) * hashGreen + vari * hashBlue;
}





// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // viewing plane (viewport) info
    vec2 viewport, ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;
    // ray
    vec4 rayDirection, rayOrigin;

    // setup
    sRay ray;
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
                 viewportHeight, fragCoord, iResolution.xy);
    calcRay(ray,viewport, focalLength);

    // color
    fragColor = calcColor(ray, iTime, iResolution.xy, fragCoord);

}


/*
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coord with respect to one dimension to avoid ellipses.
    vec2 uv = fragCoord/iResolution.yy;
    //hard coded center for my screen
    vec2 centerScreen = vec2(.89,0.5);
    float radius = cos(iTime *  .25);
    float magnitude = cos(iTime);
    //due to our changing circle being from a cos wave it dips into the negatives once in a while
    //these if statements are how I decided to correct for it.
    vec3 colorPosLeft = hashedWave(uv.yx, iTime, 3.0, 0.5);
    vec3 colorPosRight = hashedWave(uv,iTime,3.0, 0.25 );
    const float maxRadius = .25;
    if (radius >= maxRadius)
    {
        radius = maxRadius;
    }
    if(radius <= -maxRadius)
    {
        radius = -maxRadius;
    }
//    float radius = .25;
    vec4 desiredCol = vec4(hashedWave(uv / vec2(0.92,0.92), iTime, 2.5, .8), 1.0);
    vec4 circleFinalCol;
    

    vec3 splitCol;
    vec3 tempCol = vec3(uv, .25);
    //Need to make a function that splits the screen at some point
    if(splitScreen(fragCoord.x, iResolution.x , 0.5))
    {
        fragColor = vec4(vec3(colorPosLeft * tempCol), 1.0);
    }
    else
    {
    //moving box creation with the current effects being primarily blue scale. Wait long enough you will see the cos ripple.
        fragColor = vec4(colorPosRight / tempCol, 1.0);
    }
    //calculated at the end so we can see the circle.
    circleFinalCol = vec4(drawSplitCircle(uv, centerScreen, radius, fragColor, desiredCol, vec4(colorPosLeft, 1.0)));
    fragColor = circleFinalCol;
    //using barrelDistortion as a color alteration passing uv and swizzled uv.
//    fragColor +=vec4(barrelDistortion(uv,magnitude, radius),0.0,1.0);
//    fragColor -= vec4(barrelDistortion(uv.yx, magnitude,radius),0.0,1.0);
//  fragColor *= vec4(barrelDistortion(uv.xy, magnitude,radius),0.0,1.0);
//    fragColor /= vec4(barrelDistortion(uv.yx, magnitude,radius),0.0,1.0);
//    fragColor = mix(circleFinalCol,vec4(barrelDistortion(uv.yx, magnitude,radius), 0.0,1.0), 0.5f);
}
*/