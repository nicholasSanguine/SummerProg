#version 450

layout(location = 0)
	out vec4 cFragColor;
		
in vec2 vTexCoord;
uniform sampler2D uAudio;
uniform bvec4 uKeyWASD;
uniform vec2 uResolution;
uniform float uTime;
//May have an actual name somewhere but it made hashed waves
//in my practice with it.
//Originally used this function here:
//https://www.shadertoy.com/view/slXXRl
//Purpose is taking our color we want and making colorful boxes out of it.
//if you switch it to return red as it is and distort green & blue the box
//will show a bright blue sphere in our case with the same black lines and 
//deep reds where it was blue before.
vec3 hashedWave(vec3 col, float time, float magnitude)
{
    
    //Only real edit here is compressing our cos & making a one line return
    return vec3(cos(time * col.rg * magnitude) * 0.5 + 0.5,col.b);
//    return vec3(col.r, cos(time * col.gb * magnitude) * 0.5 + 0.5);
}


//https://www.geeks3d.com/20140213/glsl-shader-library-fish-eye-and-dome-and-barrel-distortion-post-processing-filters/2/
vec2 barrelDist(vec2 loc)
{
	float theta = atan(loc.y,loc.x);
	float radius = length(loc);
	//Normal equation uses pow(radius,x) I think to the pow
	//of two is enough.
	radius = radius * radius;
	loc.x = radius * cos(theta);
	loc.y = radius * sin(theta);
	return 0.5 * (loc + 1.0);
}

//Very similar to lerp in formula, practically the exact same output
vec4 alterCol(float mixVar)
{
	vec4 coolCol = vec4(0.0,0.5,1.0,1.0);
	vec4 warmCol = vec4(1.0,0.5,0.0,1.0);
	//mix formula is x * (1-a)+y*a
	//x is our coolCol, y is our warmCol, and a is mixVar
	//both give the same return one simply is more directly controlled.
	return coolCol* (1.0 - mixVar) + warmCol * mixVar;
//	return mix(coolCol,warmCol,mixVar);
}

//https://en.wikipedia.org/wiki/Linear_interpolation
//precise form lerp
//whenever t = 1 it shows col1
//formula is (1 - t) * col0 + t *col1
vec4 lerpCol(float t)
{
	vec4 coolCol = vec4(0.0,0.5,1.0,1.0);
	vec4 warmCol = vec4(1.0,0.5,0.0,1.0);
	return (1.0 - t) * coolCol + t * warmCol;
}
vec4 calcColor(vec4 distorted, vec4 compressed, vec4 normal, float time)
{
    //W
	if(uKeyWASD.x)
	{
	//Distorted - Output
	//return lerpCol(distorted.x);
	//return vec4(distorted.x);
	//return  alterCol(distorted.x);
	return vec4(hashedWave(vec3(distorted.x), time, 0.25),1.0);
	}
	//A
	else if(uKeyWASD.y)
	{
	//Compressed - Output
	return lerpCol(compressed.x);
	return alterCol(compressed.x);
	return vec4(hashedWave(vec3(compressed.x), time, 0.25),1.0);
	}
	//S
	else if(uKeyWASD.z)
	{
	//Decompressed - Output
	return lerpCol(normal.x);
	//return alterCol(normal.x);
	return vec4(hashedWave(vec3(normal.x), time, 0.25),1.0);
	}
	else
	return vec4(normal.x);
}
void main()
{
	//https://shadered.org/docs/objects.html?highlight=audio
	//tool used to verify my audio wavelengths where at least close
	//to their displayed point.
	//https://academo.org/demos/spectrum-analyzer/
	vec2 cTexCoord = vTexCoord * 2.0 -1.0;
	vec2 distCoord = barrelDist(cTexCoord);
	//Distorted
	vec4 dAudioTexture =vec4(texture(uAudio, distCoord).x);
	//Compress
	vec4 audioTexture = vec4(texture(uAudio, vTexCoord).x);
	//Decompressed
	vec4 cAudioTexture = vec4(texture(uAudio, cTexCoord).x);
	
	cFragColor = calcColor(dAudioTexture, audioTexture, cAudioTexture, uTime);

}
